
Reenigneのブログ
https://www.reenigne.org/blog/8086-microcode-disassembled/

考えていること
« 私の子供たちが通う学校の校長への手紙
8086 マイクロコードの逆アセンブル
最近、8086 リバース エンジニアリング シリーズの一環として、Ken Shirriff が金属層を除去した 8086 ダイの高解像度写真をオンラインに投稿していたことに気づきました。これは、8086 マイクロコードを抽出して逆アセンブルするために、私がしばらく探していたものでした。以前、金属層が完全な状態のダイの非常に高解像度の写真を見つけましたが、マイクロコード ROM のビットの半分しか読み取れませんでした。Ken は、8088 のマイクロコード ROM の高解像度の写真も投稿しました。これは非常に似ていますが、同一ではありません。何が違うのか非常に興味がありました。

私は、bitractを使用して 2 つのメイン マイクロコード ROM からビットを抽出し、またオペコード ビット パターンをメイン マイクロコード ROM 内の位置にマップする変換 ROM からもビットを抽出しました。

マイクロコードは米国特許 4363091に部分的に記載されています。特に、その特許にはいくつかのマイクロコード ルーチンのソース リストが含まれています。この中には、ROM ダンプで見つけることができた命令の一部の特定のパターンがあります。これにより、一文字置換暗号を解読するのと同じような方法で、ROM 内のビット パターンがマイクロコード命令セットのオペランドとオペコードにどのように対応するかを理解することができました。私のマイクロコード ROM の逆アセンブルの結果はここにあり、逆アセンブラのコードはgithub にあります。

この逆アセンブリにより、8088 と 8086 について私が抱いていた多くの質問に答えられました。この投稿の残りの部分には、これらの質問に対する答えと、マイクロコードで見つけたその他の興味深い点が含まれています。

8086 と 8088 のマイクロコードの違いは何ですか?

違いは割り込み処理コードにあります。結局のところ、8086 は割り込みを確認するために 2 つの特別なバス アクセスを実行するということになると思います (1 つは割り込みを処理する準備ができていることを PIC に伝えるため、2 つ目は処理する必要がある IRQ の割り込み番号をフェッチするため) 。これらは何らかの理由でワード サイズのアクセスであるため、8088 では 2 つではなく 4 つのアクセスに分割されます。これは PIC を混乱させる可能性があるため、8088 は代わりに 1 つのアクセスを実行し、BIU に依存してアクセスを 2 つに分割します。他の変更はこれに関連したものと思われます。

US4363091 のマイクロコード リストは正確ですか?

多くの場合。ただし、相違点もあります (解読プロセスが多少複雑になります)。違いは文字列命令にあります。たとえば、特許内の「STS」(STOSB/STOSW) 命令は次のとおりです。

CR  S      D      Type  a     b     F
-------------------------------------
0   IK     IND    7     F1    1
1   (M)    OPR    6     w     DA,BL
2   IND    IK     0     F1    0
3                 4     none  RNI

実際のCPUでは次のようになります。

0   IK    -> IND       7   F1    RPTS
1   M     -> OPR       6   w     DA,BL
2   IND   -> IK        0   NF1      5
3   SIGMA -> tmpc      5   INT   RPTI
4   tmpc  -> BC        0   NZ       1
5                      4   none  RNI

矢印は違いではありません。マイクロコード命令の「移動」部分でのデータ移動の方向を強調するために、逆アセンブリに矢印を入れただけです。同様に、特許リストの「F1 1」は、私が分解した「F1 RPTS」と同じです。読みやすくするために、サブルーチン番号を名前に置き換えました。

この特許のバージョンでは、文字列の反復を処理する前に、「RPTS」ルーチンで保留中の割り込みをチェックします。これは、割り込みの「嵐」が連続して発生すると、文字列命令は何も進まないことを意味します。CPU のバージョンはこれを修正し、ストアを実行した後に 3 行目の割り込みをチェックしてストアを続行できるようにします。これはおそらく、通常の動作では発生すると予想される状況ではありませんでした (実際、割り込みがあまりにも早く発生して処理できなくなり、8088 および 8086 マシンがクラッシュしたことを覚えているようです)。この変更は、トラップ フラグを使用したデバッグに対応するために行われた可能性が高くなります (これは本質的に、トラップ フラグが設定されているときは常に割り込みが保留中であることを意味します)。この変化がなければ、

マイクロコードによると、8086 には何種類の命令がありますか? 彼らは何ですか？

CPU には 60 個の命令があり、それらはかなり論理的な順序で配置されています。

(数値は、処理されるオペコードの数、トップレベルのマイクロコード ルーチンのサイズです。)

MOV rm<->r     4  3
LEA            1  1
alu rm<->r    32  4
alu rm,i       4  5
MOV rm,i       2  4
alu r,i       16  4
MOV r,i       16  3
PUSH rw        8  4
PUSH sr        4  4
PUSHF          1  4
POP rw         8  3
POP sr         4  3
POPF           1  3
POP rmw        1  6
CBW            1  2
CWD            1  7
MOV A,[i]      2  4
MOV [i],A      2  4
CALL cd        1  4
CALL cw        1  8
XCHG AX,rw     8  3
rot rm,1       2  3
rot rm,CL      2  8
TEST rm,r      2  3
TEST A,i       2  4
SALC           1  3
XCHG rm,r      2  5
IN A,ib        2  4
OUT ib,A       2  4
IN A,DX        2  2
OUT DX,A       2  2
RET            2  4
RETF           2  2
IRET           1  4
RET/RETF iw    4  4
JMP cw/JMP cb  2  6
JMP cd         1  7
Jcond         32  3
MOV rmw<->sr   2  2
LES            1  4
LDS            1  4
WAIT           1  9 (discontinuous)
SAHF           1  4
LAHF           1  2
ESC            8  1
XLAT           1  5
STOS           2  6 (discontinuous)
CMPS/SCAS      4 13 (discontinuous)
MOVS/LODS      4 11 (discontinuous)
JCXZ           1  5 (discontinuous)
LOOPNE/LOOPE   2  5
LOOP           1  4
DAA/DAS        2  4
AAA/AAS        2  8
AAD            1  4
AAM            1  6
INC/DEC rw    16  2
INT ib         1  2
INTO           1  4
INT 3          1  3

不連続(discontinuous)な命令は、バグ修正により元のスロットに対して長すぎるため、分割された可能性が高くなります。同様に、「POP rmw」も後ろに空白があるため、少なくとも 3 命令分短縮されているようです。コードを作成した後でコードを移動する (およびすべてのファー ジャンプ/呼び出しの位置を更新する) のは、おそらく困難だったでしょう。

マイクロコードによって処理されない命令がある場合、どの命令ですか?

セグメント オーバーライド プレフィックス (CS:、SS:、DS:、および ES:) 用のマイクロコードはありません。他のプレフィックス (REP、REPNE、および LOCK) や、CLC、STC、CLI、STI、CLD、STD、CMC、および HLT 命令も同様です。「グループ」オペコード 0xf6、0xf7、0xfe、0xff にはトップレベルのマイクロコード命令がありません。したがって、オペコードの上位ニブルに 0xf が含まれる命令は、最初はマイクロコードによって処理されません。これらの命令のほとんどは非常に単純であり、おそらくランダム ロジックで実行するほうがよいでしょう。HLT は少し驚きです。HLT は 1 サイクルおきに割り込みをチェックするだけのようなので、そのマイクロコード ループを見つけようと本気で考えました。

グループ命令は少し異なる方法でデコードされますが、それらを処理するマイクロコード ルーチンは次のように分類されます。

INC/DEC rm 3
プッシュ rm 4
RM3ではありません
NEG rm 3
遠くに電話をかける rm 8
電話 rm 8
テスト rm,i 4
JMP rm 2
JMP ファー rm 4
IMUL/MUL 人民元 8
IMUL/MUL rmw 8
IDIV/DIV RMB 8
IDIV/DIV rmw 8
次に、さまざまなサブルーチンと末尾呼び出しがあります (translation.txt にリストされています)。ハイライト:

割り込み処理 (16 マイクロ命令)
乗算と除算の符号処理、乗算のフラグ (32)
実効アドレスの計算 (16)
リセットルーチン (CS=0xffff、DS=ES=SS=FLAGS=PC=0 を設定) (6)
マイクロコードには何も行わない「ジャンク コード」が含まれていますか?

そうらしいです！ROM の未使用部分 (64 命令) のほとんどはゼロで埋められていますが、そうでない部分もいくつかあります。次の指示は ROM の最後に表示されます。

A -> tmpa 5 INT FARCALL2 011100011.0110
[ 5] -> [ a] 5 UNC INTR F 011100011.0111
実行がこれらの命令に到達する方法はないようです。このコードは、AL を tmpa (その後はまったく使用されないようです) に保存し、その後、割り込み、または (割り込みが保留中の場合) far 呼び出しを実行します。割り込みの場合、他の場所では使用されていないソースと宛先の間の移動も実行します (したがって、それらが何であるかはわかりません)。このことから、ある時点で「INT AL」命令のような計画があったのではないかと疑問に感じます。最終的に完成した x86 命令セットでは、そのようなことは、自己変更コード、INT 命令のテーブル、またはソフトウェアで INT の動作を偽装することを使用して行う必要があります。

次のコードもアクセスできず、読み書きされる最後のオフセットの下位バイトとキャリー フラグを使って何かをしているようです。

IND -> tmpaL 1 LRCY tmpc F 01010?10?.1010
それが何のためなのかはわかりません。マイクロコードの他の部分では IND レジスタを 2 つの別個のバイトとして扱っていません。

マイクロコードでまだ理解されていない部分はありますか?

非割り込みの場合に WAIT 命令が終了すると (つまり、-TEST ピンがアクティブになり、8087 が命令を完了したことを知らせることによって)、マイクロコード シーケンスは次のシーケンスを使用して終了します。

                   4 [ 1 ] なし
                   4 なし RNI
「[ 1]」が何をするのかわかりません。他では使用されていません。

「タイプ 6」 (バス IO) 操作用の明らかな機能を持たないビット (リストでは「Q」として示されている) もあります。この Q ビットは「W」(書き込み) 操作に対してのみ設定され、リスト内では小文字 (「w」) で示されることなく書き込み操作によって区別されます。どの書き込みがこのビットを使用するかについてのパターンはないようです。文字列移動命令はこれを使用します。また、割り込みが発生したときにスタックがフラグをプッシュしたり、Far 呼び出しまたは割り込みのセグメントをプッシュしたりする場合にも使用します (ただし、オフセットは使用しません)。このビットがメモリとポート IO バス アクセスを区別するために使用されるのであれば意味はありますが、CPU にはこれのための別のメカニズムがあるようです (おそらくグループ デコード ROM ですが、内容については不明な点が多すぎるためデコードしていません)その入力と出力は次のとおりです)。

CPU を高速化するためにマイクロコードを改善できた部分はありますか?

多くの命令は、後の CPU の標準からすると非常に重く実行されるように見えますが、マイクロコードは非常に厳密に記述されているようで、改善の余地はあまり見つかりませんでした。MOVS/LODS オペコードが LODS と MOVS の個別のマイクロコード ルーチンに分割された場合、LODS ルーチンは条件付きジャンプを回避し、1 サイクルより速く実行できます。しかし、「POP rmw」の短縮のため、その余地しかありません。開発サイクルのかなり遅い段階で起こった可能性があります (特に、それが最適化ではなく機能的なバグ修正だった場合、その時点では最適化が基準を満たしていなかった可能性があります)。 ）。

ジャンプの前にプリフェッチを一時停止できる場所があるかもしれませんが、それが最適化になるかどうかはそれほど明白ではありません。特に、「サスペンド」操作が同期であり、BIU が現在のプリフェッチ サイクルを完了するのを待ってからマイクロコード プログラムを続行する場合は特にそうです。特に、それによってマイクロコード ルーチンが長くなる場合はなおさらです。

もちろんランダムロジックも変更すれば改善可能です。NEC V20 および V30 は、一般に命令あたりのサイクル数が低くて同じ命令を実装していますが、トランジスタ数が 29,000 個ではなく 63,000 個であるため、おそらくマイクロコードに対するランダム ロジックの割合がはるかに大きくなります。

マイクロコードには、まだ文書化されていない隠された機能、オペコード、またはイースターエッグが含まれていますか?

します！MUL または IMUL 命令で REP または REPNE プレフィックスを使用すると、積が無効になります。IDIV 命令で REP または REPNE プレフィックスを使用すると、商が無効になります。私の知る限り、これまでにこれらを発見した人はいません（少なくとも文書化した人はいません）。

符号付き乗算と除算は、負の入力を否定し、入力の 1 つだけが負の場合は出力を否定することによって機能します。つまり、CPU は乗算と除算のアルゴリズム全体で 1 ビットの状態 (出力を否定するかどうか) を記憶する必要があります。ただし、これらのアルゴリズムは 3 つの一時レジスタすべて、内部カウンター、および ALU を使用します (そのため、たとえば、ビットを内部キャリー フラグに入れることはできません)。私はそのビットがどこに保管されるかについて頭を悩ませていました。また、なぜ乗算と除算のアルゴリズムが F1 (「REP プレフィックスがあるか?」) フラグをチェックするのかについても頭を悩ませていました。その後、これらのパズルが互いに打ち消し合っていることに気づきました。CPU は、乗算/除算入力の負の符号ごとに F1 フラグを反転します。それをチェックするためのマイクロコード命令がすでにあります。

私は、マイクロコード命令が F1 フラグを反転するのではなく設定するのではないかと考えていました。つまり、乗算による (おそらく否定された) 「絶対値」演算を (ほぼ) 無料で実行できることになります。しかし、ほぼ無料の否定も非常に優れています。REP は「NEG AX」よりも 1 バイト安く、16 ビット乗算を使用すると、節約はさらに大きくなります (NEG AX / ADC DX、0 / NEG DX が不要になります) シーケンス。乗算に比べればまだ小さいですが、それでも節約になります。

私はこれをデモシーン制作で「すべてのエミュレータを破壊します」という別の瞬間として使用することを考えましたが、8086 および 8088 CPU での乗算と除算は十分に遅いため、デモでの使用は限定的です。

F1ZZ マイクロコード命令 (REPE/REPNE SCAS/CMPS シーケンスが早期に終了するかどうかを制御する) は、LOOPE 命令と LOOPNE 命令でも使用されます。そこで、REP プレフィックスの 1 つがテストの意味を逆にするのではないかと疑問に思いました。ただし、どちらの接頭辞もこれらの命令には影響を与えないようです。

2023 年 1 月 2 日更新

ここでは、以下のコメントからのいくつかの変更を組み込んだ新しいバージョンの逆アセンブリを作成しました。グループROMを転記し、「NWB」を削除し、Wマイクロ命令にRNIフラグを追加し、XZCをADCに変更しました。

このエントリーは、2020年9月3日木曜日午後6時47分に投稿され、未分類 の下に保管されています。RSS 2.0フィードを通じて、このエントリへの応答を追跡できます。応答を残すことも、自分のサイトから トラックバックすることもできます。

53 Responses to “8086 マイクロコードが逆アセンブルされました”
貴重なニュース – 2020/09/07 | 𝚟𝚎𝚛𝚖𝚊𝚍𝚎𝚗 さん のコメント:
2020年9月7日午後3時57分
[…] 8086 マイクロコードが逆アセンブルされました。https://www.reenigne.org/blog/8086-microcode-disassembled/ […]

返事
ライアンは こう言います。
2023 年 3 月 5 日午前 3 時 49 分
こんにちは。かなり後になってしまいましたが、マイクロコード自体を解釈する 8088 用のエミュレータを作成しています。しかし、shift rm8,cl 命令で壁にぶつかったようです。CPU は、これらの命令のためにマイクロコード内のどこにジャンプするかをどのように決定しますか。アドレスの下位 3 ビットが modrm.reg に設定されているのは漠然と理解していますが、これではマイクロコード ルーチンの途中にジャンプしてしまいますよね。

ありがとう、
ライアン

返事
デビッドは次 のように言います。
2020年11月16日午前12時18分
おい、リニーニ！

どうもありがとうございます！ZIP ドキュメントに修正を送信する方法がわかりませんが、提案が 2 つあります。 w と W マイクロ命令の未知の違いは、小文字の w ops は命令を終了させず、W は終了させる可能性があるということです。不明なビットは、隠された RNI を示しているようです。100% 確信があるわけではありませんが、マイクロコードを読むと、これは保持されているようです。もう 1 つの提案は、key.txt 行 50 列 78、p の名前をビットフィールドの説明と一致するように i に変更することです。

返事
ニックは こう言います。
2021年8月28日午後3時40分
こんにちは、デイビッド。小文字と大文字の「w」を使用するというあなたの提案は、確かに最も理にかなっているようです。

私がよく理解していないことがもう 1 つあります。それは、バイトだけを書き込む場合とワードのみを書き込む場合のバス書き込みがどのように行われるかです。おそらくオペコードに依存しているのでしょうか？

返事
デビッドは次 のように言います。
2021年11月12日午後3時16分
やあ、ニック、

modregrm バイトを含むほとんどのオペコードでは、オペコードの W ビットによって、命令がバイトを使用するかワードを使用するかが決まります。(その他のオペコードについては、必要に応じて W ビットへのオーバーライドをハードコーディングしました。8086 ファミリ ユーザー マニュアルのページ 4-19、W オペコード ビットの図 4-20)。

次に、マイクロコードは内部「W」フラグを使用して、L8 命令中にジャンプするかどうか、MAXC 命令に設定するビット数、および BIU への読み取り/書き込み要求のサイズを決定します。私のエミュレータでは、バス要求が行われたとき、またはワードアラインフェッチが発生したときに、BIU に EU からコピーされた同一の W フラグがあります。

興味深い点の 1 つは (バス演算ではありません)、多くの ALU 演算が機能するには、tmpbL がロードされるときに tmpb に符号拡張する必要があるようです。これについてはまだ研究中です...

返事
デビッドは次 のように言います。
2021年11月12日午後3時29分
訂正!: W ビットは L8 マイクロップでは使用されず、MOD1 で使用されます。ごめん！

返事
ジル・ブレイザー さん のコメント：
2021年2月9日午後12時12分
科学にとって、非常に興味深い分析が必要なことがあります。それは、マイクロコードが異なる 8086 ステッピング/リビジョン間でどのように比較されるのかということです。オリジナルの 8086 には重大な割り込みバグがあり、新しいバージョンではすぐに修正されたという記事をどこかで読んだ記憶があります (場所はよく覚えていません)。あなたが分析しているのは 8086-2 で、Wikipedia によれば 1 年半後に発売され、このバグは初期の 8086 ユニットのみに影響するとされているため、その時点までに修正されている可能性があります。
そのバグが、特許のマイクロコードがプロセッサと一致しないとあなたが言及した理由である可能性があります。初期の 8086 では実際には同一であり、割り込みバグはあなたが言及した割り込みストームに関連している可能性があります。詳しいことは覚えていないので、自分で確認したい場合に備えて Google で調べてください。しかし、その特定のトピックについては満足していません。

悲しいことに、初期の 8086 はコレクターアイテムであるはずで、それらの破壊テストを行う意欲のある人は多くないと思います...

返事
マイケル・K さん のコメント：
2021年2月24日午後11時42分
これは素晴らしい作品です。公開していただきありがとうございます。それは、私がしばらく検討してきたプロジェクトについての私の考えに貢献しています。

いくつかのラベルについて質問があります。

1) EA セクションには、ファイルで定義されていない EAOFFSET および EAFINISH への無条件ジャンプがあります。しかし、2 つのラベル、:EALOAD (0x1e1) と :EADONE (0x1e3) があり、それらを指す呼び出しはありません。これらのラベルとその使用法に誤りはありますか? それとも、ここはマイクロコードの実行を促進する何かが舞台裏で起こっている場所なのでしょうか?

2) :INTR ラベルは右行にありますか? 一連の命令に従うと、0x19d ではなく 0x19e にジャンプする方が合理的です。(INT または INTO 命令の実行中は、tempC を AX に書き込むことは意味がありません)。

改めて、この件に関してご尽力いただきまして誠にありがとうございます。これは、エミュレーションおよびシミュレーション コミュニティにとって素晴らしいリソースです。

返事
アンドリューは こう言います。
2021年2月28日午後10時54分
私はあなたがそれを好きうれしい！

確かに、特定のジャンプがどこで終了するかを決定するために、舞台裏でいくつかの処理が行われています。EAOFFSET は、オフセットが存在するかどうか、および結果の EA から命令がロードされるかどうかに応じて、[i]、EALOAD、または EADONE (それぞれ 0x1de、0x1e1、および 0x1e3 行) で終了する可能性があります。同様に、EAFINISH は、結果として得られる EA から命令がロードされるかどうかに応じて、EALOAD または EADONE になる可能性があります。

8088 の INTR が 0x19e であることについては正しいと思います。8086 では 0x19d が正しい値ですが、8088 の変換テーブルをやり直さなかったので、0x19e を使用するとコードがより意味を成します。これは、私のサイクル正確なエミュレーション実験における予期せぬタイミングの原因にもなる可能性があるので、ご指摘いただきありがとうございます。

他の人から寄せられたフィードバックに基づいて他にもいくつか改善すべき点があるので、その変換テーブルを再確認し、すぐに更新するつもりです。

あなたのプロジェクトについてもっと知りたいです!

返事
8086 マイクロコードを逆アセンブル #VintageComputing « Adafruit Industries – メーカー、ハッカー、アーティスト、デザイナー、エンジニア! 言います：
2021年3月11日午後2時22分
[…] Intel 8086 とその親戚である 8088 は、1980 年代初頭に PC 革命を引き起こしました。Reenigne ブログは、8086 マイクロコードのデコードに関する研究を投稿しました。これは、チップ自体内でエンコードされた命令であり、[…]

返事
rasz_pl さん のコメント：
2021年5月9日午前6時15分
REP MOV アーティファクトの存在について、セカンド ソース/クローン 8088/8086 チップ、NEC V20 や К1810ВМ86 などのチップを調査しましたか?

返事
アンドリューは こう言います。
2021年5月9日午前7時24分
私には、プログラムを実行するためのチップを搭載したマシンも、分解するための写真も持っていません。V20 のすべての違いを考慮すると、REP MUL がそこでも同じように機能したとしても驚くべきことです。К1810ВМ86 が Intel 8088/8086 とどの程度似ているかはわかりません。

返事
ニックは こう言います。
2021年5月14日午後10時15分
この情報を公開していただきありがとうございます。translation.txt の内容と、translation.txt に含まれる各マイクロ命令が何を行うのかを理解するのが困難です。また、UNC ジャンプ先 (UNC 5 や L8 2 など) についても少し混乱しています。これらは命令の先頭からのオフセットですか?

また、MOV reg, mem (10001001) のような命令がどのように機能するか完全には理解していません。マイクロコードは R -> tmpb (R は modrm で指定されたレジスタ) に移動し、EA (どの EA がここで理解されているかはわかりません) に書き戻してから、tmpb -> M に移動します。これはどのようにして からの移動を構成しますか?メモリを登録しますか？それとも方向ビットに応じて何かを変更する必要がありますか？

残念ながら、この情報は特許や 8086 iAPX マニュアルなどの他の文書からは得られません。私の質問に答えていただけたり、情報源を教えていただければ幸いです。

返事
アンドリューは こう言います。
2021年5月14日午後10時57分
translation.txt ファイルには、「5 UNC」命令に現れるサブルーチン番号などのサブルーチン番号を取得し、それらをマイクロコード プログラム内の位置に変換する、変換 ROM のデコードされた内容が含まれています。これらの置換は逆アセンブリ リストですでに行われているため、たとえば、「5 UNC 1」の代わりに「5 UNC NEARCALL」が表示されます。

「0 L8 2」はショートジャンプで、「L8」(即値は1バイト)条件を条件とします。これは短いジャンプであるため、宛先 (2) は変換テーブルで検索されませんが、宛先はマイクロコード位置の下位ビットを交換することによって形成されます。したがって、条件が true の場合、行 00c の「0 L8 2」はローカル アドレス .0010 にジャンプします。これにより、00e に進みます (行 00d をスキップして、キューから 2 番目の即時バイトをフェッチし、それを tmpbH に置きます)。したがって、命令 (またはサブルーチン) の先頭からのオフセットは、それを考える良い方法です (ただし、すべてのサブルーチンが .0000 で始まるわけではありません)。

0100010?? これは非常に複雑で、多くの側面がマイクロコードではなくランダム ロジックによって制御されます。行 000 の R (ソース オペランド) は、命令のビット 1 に応じて、r フィールドで指定されたレジスタ、または rm フィールドで指定された位置のいずれかです。行 000 はこれを tmpb に移動し、行 001 は tmpb を R ではなかったレジスタ/場所である M に移動します。「MOV mem, reg」の場合は、行 002 も実行され、メモリ書き込みを実行するためのバス操作が開始されます。

したがって、これらの命令の一部は、マイクロコードによってどの部分が実行され、どの部分が実行されないかを確認できるように、その命令が実際に何を行うのかを念頭に置いて読む必要があります。

返事
ダン・タンさんは こう言います。
2022 年 7 月 23 日午後 1 時 8 分
これはとても素晴らしい作品です。このリバースエンジニアリング作業に基づいて、8086/8088 エミュレータを開発する予定です。マイクロコード ROM (stage1 および stage2) に関する情報で十分です。Translation ROMとGroup ROMのビット内容を提供すると便利ですか。特に、Translation.txt ファイル内の各フィールドの定義はどうでしょうか?

返事
アンドリューは こう言います。
2022年7月23日午後1時57分
ありがとう！

グループROMは転記しておりません。変換 ROM のビット コンテンツは、translation.txt の最初の 4 列です。このファイルの 2 列目と 3 列目は、その行のジャンプ先となるマイクロコード ROM 内の「アドレス」です (9 ビットの「オペコード」および 4 ビットの「サブオペコード」として)。最後の 3 列は、そのアドレスが実際に何に対応するか (デコード アドレス、行番号、意味の一致) を示します。最初の列は、使用する変換 ROM の行を選択するためのデコーダです。

ビット 0 は、「5」または「7」の命令タイプに対応します (0 はジャンプ、1 は呼び出し)。
ビット 1 ～ 4 はサブルーチン番号 (0 ～ 9) に対応します。
ビット 5 は、EALOAD と EADONE のどちらかを選択するためにのみ使用されます (したがって、この EA 命令がロードであるかストア/LEA であるかを決定するロジックから来ている必要があります)。
ビット 6 は EA バイト デコードの場合は 1、それ以外の場合は 0 です。EA バイトのデコードの場合、EA の場合、ビット 0 ～ 4 は EA バイトの mod および R/M フィールドから取得されます。
ビット 7 は、追加のオフセット バイトをロードするかどうかを選択するために使用されるため、「mod == 0」のようなロジックから取得する必要があります。

4 列目は [SI] の 0 です。[DI]、[BX]、および [iw] EA、および [BP] EA の場合は 1 であるため、セグメント オーバーライドがない場合にデータ セグメントまたはスタック セグメントをデフォルトにするかどうかを CPU が決定する方法を決定する必要があります。

返事
ダン・タンさんは こう言います。
2022 年 7 月 23 日午後 2 時 15 分
どうもありがとうございます！

返事
アンドリューは こう言います。
2022年7月23日午後1時59分
あなたのエミュレータが完成したらぜひ見てみたいと思っています。サイクル正確な 8088 エミュレータが役立つと思ったことが何度もありましたが、この分野での私自身の取り組みは未完成のままです (ただし、ほとんどの場合正確ですが)。

返事
ダン・タンさんは こう言います。
2022 年 7 月 23 日午後 2 時 16 分
どうもありがとうございます！

返事
ダン・タンさんは こう言います。
2022 年 7 月 24 日午前 5 時 59 分
このエミュレータの実装には、ハードウェアの実際の状態をよりよく反映できる Verilog を使用する予定であり、実際のハードウェアで検証するかどうかを検討しています。Stage1 ROMについて質問があります。このリンク ( https://forum.vcfed.org/index.php?threads/8088-8086-microcode-disassembly.77933/) 「受信したオペコードがこれらのそれぞれと (同時に) 比較され、正しい開始位置が選択される」と記載されています。つまり、各 8 ビット オペコードが Stage1 ROM 内の 128 データと比較され、Stage2 ROM 内のオペコードの座標が取得されます。このソリューションはハードウェアに実装できません。ROM のデータは 1 クロック サイクルで 1 回しか読み取れません。Stage2 ROM の座標を取得するには、128 回の比較が必要であり、これには 128 クロック サイクルが必要ですが、これは非現実的です。通常、8 ビットのオペコードを使用して Stage1 ROM に直接インデックスを付け、比較せずに Stage2 ROM の座標を取得する必要があります。Stage1 ROMのデータの順番を調整したのか分かりませんが？少なくとも現時点では、直接インデックスを作成する方法はないようです。

返事
アンドリューは こう言います。
2022 年 7 月 24 日午前 7 時 33 分
私は Verilog であまり多くのことをやったことがありませんが、Verilog が物事を並行して実行するのに非常に優れていることは理解しています。受信したオペコードのコピーを 128 個作成し、それらを 128 個のセレクターすべてと並行して比較することはできないでしょうか? これは本質的に、オリジナルの 8088 および 8086 CPU が行うことです。データの順序を調整していません。そして、はい、一部の命令は他の命令よりも複雑であるため、直接インデックス付けは機能しません。行 008 ～ 00b は 32 のオペコードをカバーし、オペコード 0xFE ～ 0xFF は行 020 ～ 022、024 ～ 027、04c ～ 053、068 ～ 06a、 074-076、098-09b、0d8-0df、150-16f (サブルーチンは含まない)。

返事
ダン・タンさんは こう言います。
2022 年 7 月 24 日午前 9 時 26 分
なるほど、分かりました。あなたのアイデアを試してみます。どうもありがとうございます。

返事
ファイアーは こう言います：
2023 年 1 月 1 日午前 3 時 58 分
Stage1 ROM を、ワイルドカードを使用して自動生成された 128 エントリの casez ステートメントとして実装するだけです。

このようなコードはどれほど肥大化しているように見えますが、FPGA 上でコンパイルするとかなり小さくなるはずです。計算が正しければ、コンパイルすると 28 個の 4-LUT になるはずです

返事
ジャンルカ さん のコメント：
2022 年 10 月 18 日午前 11 時 35 分
やあ！
まず最初に、あなたの素晴らしい仕事に感謝します。それ自体が興味深いだけでなく、私のプロジェクトにとって非常に役に立ちます。

つまり、私のプロジェクトは、マザーボード、VGA カード、I/O 管理、OS/ソフトウェアなどを含む、8086 を中心に完全に機能するコンピューター全体を設計および構築することです。すでに 8086 と逆アセンブルされたマイクロコードを使用していくつかの実験を行っています
。ついに私の質問の一つに答えました:

Q: 8086 が起動すると、最初の命令をフェッチするまでに 6 クロック サイクルかかるのはなぜですか?
A: マザーボードの設計が正しいと仮定すると、8086 が最初に実行するのは RESET ルーチンの実行であり、これにはちょうど 6 クロック サイクルかかります。

現在海外にいますが、1ヶ月ほどで帰国する予定です。
一方、私はマザーボードの設計を助けるためと、海外にいる間に何かをするために、できるだけ正確にしようと 8086 エミュレータの開発を開始しました。microcode_8086.txt のマイクロコードのほとんどを理解できたと思いますが、まだいくつか質問があります。

- 8086 ファミリのユーザー マニュアル (4-38 ページの図 4-22) の実行例とともにマイクロコードを調べると、W と w の違いは、David が最初のコメントで指摘したように、 W には隠し RNI が含まれますが、w には含まれません。
これは、「バス操作」命令タイプ 110dixssuu (ファイル「key.txt」) の「x」が RNI フラグである可能性があることも意味します。マイクロコードを詳しく見て、文字 A...U を解読しようとすると、ビット "x" は書き込み操作でのみ使用されているようです。これは、他のバス操作では命令が終了しないことを意味します (これはある意味理にかなっています) ）。
あなたはそれについてどう思いますか？

- 私が理解するのに苦労しているのは、F1 が FLAGS レジスタのビット 1 (またはその否定) を参照しているのか、それとも別の何かを参照しているのかということです。
これは、RESET 中に FLAGS がゼロで初期化されるという事実と (どういうわけか) 一致しますが、LAHF のような命令は、ビット 1 が 1 に設定された何かを AH にロードします。しかし、私が完全に間違っている可能性もあり、F1 は他の隠されたものを参照しています。登録。
私の考えが正しければ、REP LAHF (または REP PUSHF) のようなものに何を期待しますか? それとも、さらに、AH & 0x02 == 0x00 の場合、SAHF MUL ですか?
それ以外の場合、FLAGS はどのようにマッピングされるのでしょうか? 言い換えれば、RESET ルーチンが FLAGS をすべて 0 に初期化するのに、なぜビット 1 が 1 に設定されるのでしょうか?
家に帰ったら、他の実験もできるし、両方のチップで「REP MUL」機能をテストすることもできるかもしれません (はい、2 つ持っていますが、1 つは違う/新しいように見えます)。 。

- 最後に、「グループ デコード ROM」がランダム ロジックの実行および/またはマイクロコード上の正しいルーチンのロードを担当していると仮定します。
つまり、私の考えでは、FC (8086 特許の「第 1 クロック」) では命令の最初のバイトが「グループ デコード ROM」にロードされ、SC (8086 特許の「第 2 クロック」) では何が起こるかということです。特許）ランダム ロジックが実行されるか、マイクロコード ルーチンが実行されます。
これは正しいですか (または、少なくとも適切な近似値です)。

他にも質問があるかもしれません (実際、これはマイクロコード内の [ABCDE] と [FGHIJ] によって与えられる位置マッピングに関する推測です) が、それらは (少なくとも現時点では) エミュレータにとって重要ではありません。

返事
アンドリューは こう言います。
2022年12月2日午後2時22分
はい、RNI を意味する「バス操作」命令タイプの「x」については正しいと思います。この追加を加えて zip ファイルを更新します。

F1 (およびセグメント オーバーライド プレフィックスの内部フラグ) が FLAGS レジスタの未使用ビットに保持されるというのは良いアイデアですが、そうではないようです。PUSHF と LAHF のすべての組み合わせを試してみたところ、効果はありませんでした。FLAGS の未使用ビットは配線されているだけで、どちらかに設定できるフリップフロップは存在しないのではないかと思います。

試したことはありませんが、SAHF が MUL の出力を変更するとは思えません。その組み合わせは実際には有効な命令のペアであるため、変更した場合は CPU のバグになります。また、SAHF はプレフィックス命令ではないため、F1 フラグはその最後にクリアされます。

グループ デコード ROM は、どの命令が実行されているかに基づいて、23 個 (おそらく) の内部フラグを設定します。今ではほぼ理解できました。マイクロコードのどこで実行が開始されるかは決まりません (これはステージ 1 デコーダーの仕事です)。

この特許によれば、FC は最初のオペコード バイトがプリフェッチ キューから削除されるときのサイクル、SC はその後のサイクル (EA バイトが存在する場合は削除されるとき) です。

他のご質問やご意見もお待ちしております。

返事
トニーB さん のコメント：
2022年12月11日午前10時59分
Ken Shirriff の最近のブログ投稿は、より多くの洞察を提供しますか?
https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html

返事
アンドリューは こう言います。
2022年12月14日午後12時
その特定の投稿は、ほとんどが、マイクロコード ROM のデコードからすでに推測したことを確認し、明確にしただけです。しかし、Ken の以前の投稿は、グループ ROM を理解するために必要な重要な手がかりを私に与えてくれました。

返事
セイバーは こう言います。
2023 年 1 月 19 日午前 1 時
お疲れ様でした。これは、8086 の命令クロックを理解するのに非常に役立ちます。

しかし、私を混乱させることが 1 つあります。PUSH REG、PUSH SEG、PUSHF はすべて同様のことを実行し、マイクロコードでも同様です。「MCS-86 Assembly Language Reference Guide」(1978 年 10 月、9800749-1) では、これら 3 つの命令はすべて 10 クロックかかりますが、これは私にとっては合理的だと思われます。しかし、後の「The 8086 Family User's Manual」(1979 年 10 月 9800722-03) では、PUSH REG のコストは 11 クロックですが、他の 2 つは 10 クロックのままです。どうしてこんなことが起こるのでしょうか？私の意見では、オペランドとして REG にアクセスする場合、SEG より多くのクロックがかかることはありません。

返事
アンドリューは こう言います。
2023 年 1 月 19 日午前 7 時 36 分
これは 8086 ファミリ ユーザー マニュアルの単なる間違いだと思います。他にも間違いを見つけました。

返事
8086 プロセッサーの条件付きジャンプ回路のリバース エンジニアリング #Intel #ReverseEngineering #x86 @kenshirriff « Adafruit Industries – メーカー、ハッカー、アーティスト、デザイナー、エンジニア! 言います：
2023年1月24日午後3時10分
[…] 8086 のマイクロコードは、私のダイの写真から Andrew Jenner (リンク) によって逆アセンブルされたため、8086 がそれぞれどのようなマイクロ命令を実行しているかを正確に確認できます。

返事
黄禄轩 はこう言います。
2023年1月25日午後4時18分
WAIT 命令の未知のマイクロコードが一時的な割り込みの無効化に関係しているのではないかと思います。
https://twitter.com/HuangLuxuanCNSN/status/1618277628611563520

返事
アンドリューは こう言います。
2023年1月25日午後5時19分
ああ、それは完全に理にかなっています - ありがとう! 同じ信号が他のプレフィックス (セグメント オーバーライド、REP/REPNE、LOCK) によってトリガーされると思います。

返事
黄禄轩 はこう言います。
2023 年 1 月 26 日午前 2 時 07 分
はい、グループ デコーダ出力の 1 つがプレフィックスによってトリガーされ、この信号とグループ デコーダの最後の 2 スロットのデコーダ出力とともに 4 入力またはゲートに入ります。

返事
黄禄轩 はこう言います。
2023 年 1 月 28 日午前 2 時 55 分
ところで、信号に名前を付けますか?

返事
アンドリューは こう言います。
2023年1月28日午後3時56分
もしかしたら「サスペンド割り込み」かもしれません。ただし、これ（および「POP sr」/「MOV sr」命令）がセグメントオーバーライド、REP/REPNE、およびLOCKフラグをクリアするのではなく、他の方法でプレフィックスのように機能するかどうかに興味があります。もしそうなら、私はその信号に「プレフィックス」という名前を付けたくなるかもしれません。

返事
黄禄轩 はこう言います。
2023 年 1 月 31 日午前 7 時 49 分
違うと思います。グループ デコーダ出力からの信号は 4 入力またはゲートに送られ、uC.op=1001110yyy (INT) でテストされる信号が次の命令をロードする代わりに CPU 応答に割り込むのをブロックするだけでなく、別のデュアル入力にも送られます。 not-and ゲートを入力します。通常、IR およびその他のレジスタが内容をロードすると、ゲートは正のパルスを出力しますが、信号が High の場合は Low のままです。ken shirriff の画像では、信号はグループ デコーダーの一番下から一番上まで 0 から数えた Q[11] です。私のプロジェクトでは、IR_W が High の場合、IR.DI[8] が IR[8] にロードされます。IR.DI[8]=INT_PENDING&&!SUSP_INT。SUSP_INT=(IR==0x08E||IR&0x1E7==0x007)||(GROUP.Q[11]||uC.SUSP_INT)。uC.SUSP_INT はフリップフロップで、uC.OP==1001000yyy の場合は 1 に設定され、phi2 の立ち下がりエッジで IR_W!=0 の場合は 0 に設定され、RST の場合は非同期で 0 に設定されます。フリップフロップ出力は

返事
黄禄轩 はこう言います。
2023 年 1 月 31 日午前 9 時 15 分
まず、デュアル入力の not-and ゲートがプレフィックス フラグのリセットに使用されていることを確認しました。F1 がリセットされます。
次に、F1は2つあります。そのうちの 1 つは NF1 と F1 によってテストされ、もう 1 つは F1ZZ によってテストされます。
F1 は、(IR&0x1FE)==REPNZ&&IR_W のときにセットされ、デュアル入力 not-and ゲート出力が High になるとリセットされ、uC.OP==CF1 のときに反転します。uC.JF1、uC.JNF1 がそれ​​をテストします。
もう一方の F1 は、(IR&0x1FE)==REPNZ&&IR_W||uC.OP==CF1 の場合に IR[0] に設定され、何が起こってもその内容を他の条件で保持します。uC.JF1ZZ の場合、フラグ XOR ZF がテストされます。
そして、なぜF1をF1と名付けたのか気になります。そしてもう一つのF1には何という名前をつけたいですか？

返事
アンドリューは こう言います。
2023年1月31日午後3時54分
REP フラグの「F1」という名前は、8086 の内部構造を説明した特許 (US4363091) に由来しています。おそらく 2 番目のものは、Z (ZF) と XOR されて F1ZZ が形成されるため、F1Z と呼ばれるはずです。

返事
黄禄轩 はこう言います。
2023 年 1 月 29 日午前 9 時 21 分
私が気づいたもう 1 つの点は、alu 操作における NWB WB と NX は RNI スキッピングに影響を与えないということです。mmm がメモリを参照する場合、RNI は常にスキップされる可能性があります。alu 操作における NWB、WB、NX の唯一の違いは、NWB では常にローダーが次の命令の準備を行うのに対し、他の 2 つはいくつかの条件が満たされた場合にのみ NXT を発行することです。NXT=NWB||((WB||ALU_NX)&&(cond1||cond2||cond3))

返事
アンドリューは こう言います。
2023 年 1 月 29 日午前 10 時 07 分
はい、それは私も気づいたことであり、私のエミュレーターコードはこれを反映しています: https://github.com/reenigne/reenigne/blob/6ee16df0d974ff41e8591294b9349701fc01233d/8088/xtce/xtce_microcode.h#L2764。また、今月初めのマイクロコード逆アセンブリの最新アップデートで、「NWB,NX」を単に「NX」に変更しました。これは、この操作の動作が ALU プライミング マイクロ命令の NX ビットとまったく同じであると思われるためです。

返事
黄禄轩 はこう言います。
2023 年 1 月 29 日午前 11 時 50 分
いいえ、チップで見たとおり、WB,NX は ALU NX と同じ動作をします。したがって、宛先が mmm で mmm がメモリを参照している場合、ALL RNI がスキップされるように見えるため、WB,NX を削除した方が良いと思います。スキップ ロジックは RNI=uc.op.RNI&&(uc.dst!=10010(MMM)||cond2||cond1) です。RNI 論理式の cond2 と cond1、NXT 論理式の cond2 と cond 1 は同じ信号です。私のプロジェクトを紹介しますので、よろしかったら私の言いたいことを理解してください。

返事
アンドリューは こう言います。
2023年1月30日午後4時06分
ああ、あなたの言いたいことはわかりました。はい、ALU NX の実装 (私のエミュレータでは「if (_mIsM && _useMemory && _alu != 7 && (_group & groupEffectiveAddress) != 0) _nx = false;」) は、WB,NX の実装によく似ています ( "if (!_mIsM || !_useMemory || _alu == 7) _nx = true;") よりも NWB,NX ("_nx = true;") になります。最初の 2 つをマージできる可能性がありますが、私は確認していません。あなたのプロジェクトを見てみたいと思っています。

返事
黄禄轩 はこう言います。
2023 年 1 月 31 日午前 7 時 56 分
現時点では、自分のプロジェクトを公開したくありません。それは、プロジェクトが乱雑で、私の思い込みが多く含まれており、間違っている可能性があるためです。それで個人的に送りたいのですが、あなたのツイッターやディスコードなどを知りません。

返事
アンドリューは こう言います。
2023 年 1 月 31 日午前 8 時 57 分
私の Twitter は @iomonad、Discord は reenigne#5496、電子メール アドレスはandrew@reenigne.orgです。

返事
黄禄轩 はこう言います。
2023 年 2 月 6 日午前 7 時 51 分
RNI と NX を生成する詳細なロジックがあります。
https://twitter.com/HuangLuxuanCNSN/status/1622501443684143104
(ちなみに、Ctrl+Enterで改行しようとしているので、間違って間違ったリプレイを送ってしまった可能性があります。無視してください。)

返事
黄禄轩 はこう言います。
2023年2月11日午後1時31分
新しい発見: チップ内に別の ZF が隠されており、私はそれを ΣZF または SZF と呼び、NZ によってテストされています。Z は ZF をテストします。ZF と SZF の詳細なロジック: https://twitter.com/HuangLuxuanCNSN/status/1624386607389503489

返事
Intel 8086 プロセッサの割り込み回路をリバース エンジニアリングすると、次のように なります。
2023年2月21日午後5時28分
[…] 8086 のマイクロコードは、私のダイの写真から Andrew Jenner (リンク) によって逆アセンブルされたため、マイクロコードのリストは彼のデータに基づいています。

返事
Intel 8086 プロセッサの ModR/M アドレス指定マイクロコードをリバース エンジニアリングすると、次のようになります 。
2023 年 2 月 27 日午後 6 時 39 分
[…] マイクロコードのリストは、Andrew Jenner の逆アセンブリに基づいています。(うまくいけば) 簡単にするためにいくつかの変更を加えました […]

返事
ライアンは こう言います。
2023 年 3 月 5 日午前 3 時 56 分
こんにちは。かなり後になってしまいましたが、マイクロコード自体を解釈する 8088 用のエミュレータを作成しています。しかし、shift rm8,cl 命令で壁にぶつかったようです。CPU は、これらの命令のためにマイクロコード内のどこにジャンプするかをどのように決定しますか。アドレスの下位 3 ビットが modrm.reg に設定されているのは漠然と理解していますが、これではマイクロコード ルーチンの途中にジャンプしてしまいますよね。

ありがとう、ライアン

返事
アンドリューは こう言います。
2023 年 3 月 15 日午後 2 時 36 分
これらの命令は、マイクロコード リストの行 08c ～ 093 にあります。ライン 08c の命令ビットは 01101001?.00 で、オペコード 0xd4 および 0xd5 に対応し、カウント レジスタは 0 から 7 になります。したがって、マイクロコード ROM は基本的に 9 ビットのオペコードとカウント レジスタの上位 2 ビットをすべてのビットと比較します。一度に 128 セットの命令ビットを実行し、アクティブ化されたセットに対応するマイクロコードを実行します。Ken Shirriff のブログ投稿では、マイクロコードがどのように機能するかについてさらに詳しく説明されています。また、 https://github.com/reenigne/reenigne/blob/master/8088/xtce/xtce_microcode.hで、マイクロコードを解釈する 8088 エミュレータを作成する試みをご覧いただくこともできます(まだ完成していない可能性があります)。トラップ フラグ、未定義フラグ、命令間の割り込みのタイミングに関するいくつかの問題)。

返事
8086 プロセッサのマイクロコードのレジスタ コードをリバース エンジニアリングすると、次のように なります。
2023 年 3 月 11 日午後 5 時 57 分
[…] マイクロコードのリストは、Andrew Jenner の逆アセンブリに基づいています。(うまくいけば) 簡単にするためにいくつかの変更を加えました […]

返事
Intel 8086 プロセッサの乗算アルゴリズムをリバースエンジニアリングすると、次のように なります。
2023年3月15日午後4時22分
[…] 私のマイクロコード分析は、Andrew Jenner の 8086 マイクロコード逆アセンブリに基づいています。 ↩[…]

返事
Intel 8086 プロセッサの除算マイクロコードをリバース エンジニアリングすると、次のように なります。
2023年4月8日午後4時28分
[…] 私のマイクロコード分析は、Andrew Jenner の 8086 マイクロコード逆アセンブリに基づいています。 ↩[…]

返事
返信を残す
 名前

 メール（公開されません）

 Webサイト


Reenigne ブログは、WordPress
エントリー (RSS)とコメント (RSS)を誇りを持って提供しています。